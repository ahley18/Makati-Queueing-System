<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Queue Admin Dashboard</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Inter', sans-serif;
      background: #f1f5f9;
      color: #334155;
    }
    /* Sidebar */
    .sidebar {
      position: fixed;
      left: 0; top: 0; bottom: 0;
      width: 250px;
      background: #1e293b;
      padding: 20px;
      color: white;
      display: flex;
      flex-direction: column;
      z-index: 2;
    }
    .logo {
      font-size: 1.5rem;
      font-weight: 700;
      margin-bottom: 40px;
      padding-bottom: 20px;
      border-bottom: 1px solid #334155;
    }
    .nav-item {
      display: block;
      padding: 12px 16px;
      margin-bottom: 8px;
      color: #cbd5e1;
      text-decoration: none;
      border-radius: 8px;
      transition: all 0.2s;
      font-size: 1.08rem;
      cursor: pointer;
      border: none;
      background: none;
      text-align: left;
    }
    .nav-item:hover, .nav-item.active {
      background: #334155;
      color: white;
    }
    .sidebar-footer {
      margin-top: auto;
      padding: 20px 0 0 0;
      border-top: 1px solid #334155;
      background: #1e293b;
    }
    .user-info { margin-bottom: 15px; }
    .user-info span {
      display: block;
      color: white;
      font-weight: 600;
      margin-bottom: 5px;
    }
    .user-info small {
      color: #cbd5e1;
      font-size: 0.8rem;
    }
    .logout-btn {
      width: 100%;
      padding: 10px;
      background: #dc2626;
      color: white;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .logout-btn:hover { background: #b91c1c; }
    /* Main Content */
    .main-content {
      margin-left: 250px;
      padding: 30px 18px;
      min-height: 100vh;
    }
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 30px;
    }
    .page-title {
      font-size: 2rem;
      font-weight: 700;
      color: #1e293b;
    }
    .header-actions { display: flex; gap: 15px; }
    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 1rem;
    }
    .btn-primary { background: #3b82f6; color: white; }
    .btn-primary:hover { background: #2563eb; }
    .btn-secondary { background: #e5e7eb; color: #334155; }
    .btn-danger { background: #dc2626; color: white; }
    .btn-danger:hover { background: #b91c1c; }
    /* Stats Grid */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }
    .stat-card {
      background: white;
      padding: 25px;
      border-radius: 12px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    }
    .stat-label {
      font-size: 0.9rem;
      color: #64748b;
      margin-bottom: 8px;
    }
    .stat-value {
      font-size: 2.5rem;
      font-weight: 700;
      color: #1e293b;
      margin-bottom: 10px;
    }
    .stat-change { font-size: 0.85rem; font-weight: 600; }
    .stat-change.positive { color: #10b981; }
    .stat-change.negative { color: #ef4444; }
    /* Counter Grid */
    .counter-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }
    .counter-control {
      background: white;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    .counter-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    .counter-title { font-weight: 600; font-size: 1.1rem; }
    .status-badge {
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 600;
      text-transform: uppercase;
    }
    .status-open { background: #10b981; color: white; }
    .status-closed { background: #ef4444; color: white; }
    .status-break { background: #f59e0b; color: white; }
    .counter-info { margin-bottom: 15px; }
    .info-row {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid #e2e8f0;
    }
    .info-label { color: #64748b; font-size: 0.9rem; }
    .info-value { font-weight: 600; }
    .counter-actions { display: flex; gap: 10px; }
    .btn-small { padding: 8px 16px; font-size: 0.9rem; }
    /* Table */
    .table-container {
      background: white;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      overflow-x: auto;
      margin-bottom: 30px;
    }
    table { width: 100%; border-collapse: collapse; }
    th {
      text-align: left;
      padding: 12px;
      font-weight: 600;
      color: #64748b;
      border-bottom: 2px solid #e2e8f0;
    }
    td { padding: 12px; border-bottom: 1px solid #f1f5f9; }
    tr:hover { background: #f8fafc; }
    /* Analytics charts (placeholders) */
    .charts-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }
    .chart-container {
      background: white;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      max-height: 340px;
      min-height: 240px;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
    }
    .chart-title {
      font-size: 1.2rem;
      font-weight: 600;
      margin-bottom: 20px;
    }
    .chart-container canvas {
      max-height: 280px;
      height: 280px !important;
      width: 100% !important;
      display: block;
    }
    /* Responsive */
    @media (max-width: 900px) {
      .sidebar { width: 180px; }
      .main-content { margin-left: 180px; padding: 16px 6px; }
      .charts-grid { grid-template-columns: 1fr; }
    }
    @media (max-width: 768px) {
      .sidebar { position: relative; width: 100%; }
      .main-content { margin-left: 0; padding: 8px 2px; }
      .header { flex-direction: column; gap: 10px; }
    }
  </style>
</head>
<body>
  <aside class="sidebar">
    <div class="logo">üèõÔ∏è Queue Admin</div>
    <nav>
      <button class="nav-item active" id="nav-overview" onclick="showSection('overview', event)">üìä Overview</button>
      <button class="nav-item" id="nav-counters" onclick="showSection('counters', event)">üñ•Ô∏è Counters</button>
      <button class="nav-item" id="nav-tickets" onclick="showSection('tickets', event)">üìã Tickets</button>
      <button class="nav-item" id="nav-settings" onclick="showSection('settings', event)">‚öôÔ∏è Settings</button>
    </nav>
    <div class="sidebar-footer">
      <div class="user-info">
        <span id="currentUser">Admin</span>
        <small id="loginTime">Logged in today</small>
      </div>
      <button class="logout-btn" onclick="logout()">üö™ Logout</button>
    </div>
  </aside>
  <main class="main-content">
    <!-- Overview Section -->
    <section id="overview" class="section">
      <div class="header">
        <h1 class="page-title">Dashboard Overview</h1>
        <div class="header-actions">
          <div style="display: flex; align-items: center; gap: 10px;">
            <label for="overviewDateFilter" style="font-weight: 600; color: #374151;">Filter by Date:</label>
            <input type="date" id="overviewDateFilter" style="padding: 8px 12px; border: 1.5px solid #e5e7eb; border-radius: 6px; font-size: 0.9rem;">
            <button class="btn btn-primary" onclick="applyOverviewDateFilter()" style="padding: 8px 16px; font-size: 0.9rem;">Apply Filter</button>
            <button class="btn btn-secondary" onclick="clearOverviewDateFilter()" style="padding: 8px 16px; font-size: 0.9rem;">Clear</button>
          </div>
          <button class="btn btn-primary" onclick="loadOverview()">üîÑ Refresh</button>
        </div>
      </div>
      <div class="stats-grid">
        <div class="stat-card">
          <div class="stat-label">Total Tickets Today</div>
          <div class="stat-value" id="stat-total">0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Currently Serving</div>
          <div class="stat-value" id="stat-serving">0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Waiting</div>
          <div class="stat-value" id="stat-waiting">0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Service Rate</div>
          <div class="stat-value" id="stat-rate">0%</div>
        </div>
      </div>
      <!-- You can add charts here if needed -->
      <div class="charts-grid">
        <div class="chart-container">
          <h3 class="chart-title">Hourly Ticket Distribution</h3>
          <canvas id="hourlyChart" width="400" height="200"></canvas>
        </div>
        <div class="chart-container">
          <h3 class="chart-title">Service Performance by Counter</h3>
          <canvas id="performanceChart" width="400" height="200"></canvas>
        </div>
      </div>
      <!-- In Depth Analytics Section -->
      <div class="in-depth-analytics-section" style="margin-top: 30px;">
        <div class="analytics-toggle" style="display: flex; flex-direction: column; align-items: center; margin-bottom: 20px;">
          <button id="toggleAnalyticsBtn" class="btn btn-secondary" onclick="toggleInDepthAnalytics()" style="display: flex; align-items: center; gap: 8px;">
            <span id="toggleIcon">üìä</span>
            <span id="toggleText">Show In Depth Analytics</span>
          </button>
        </div>
        <div id="analyticsDateFilter" style="display: none; margin-bottom: 20px; padding: 20px; background: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0;">
          <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
            <label for="analyticsDateFilter" style="font-weight: 600; color: #374151;">Filter Analytics by Date:</label>
            <input type="date" id="analyticsDateFilterInput" style="padding: 8px 12px; border: 1.5px solid #e5e7eb; border-radius: 6px; font-size: 0.9rem;">
            <button class="btn btn-primary" onclick="applyAnalyticsDateFilter()" style="padding: 8px 16px; font-size: 0.9rem;">Apply Filter</button>
            <button class="btn btn-secondary" onclick="clearAnalyticsDateFilter()" style="padding: 8px 16px; font-size: 0.9rem;">Clear</button>
          </div>
        </div>
        <div id="inDepthAnalyticsContent" style="display: none;">
          <div class="charts-grid">
            <div class="chart-container">
              <h3 class="chart-title">Daily Ticket Trend (Last 7 Days)</h3>
              <canvas id="dailyTrend7Chart" width="400" height="200"></canvas>
            </div>
            <div class="chart-container">
              <h3 class="chart-title">Service Type Distribution</h3>
              <canvas id="serviceDistributionChart" width="400" height="200"></canvas>
            </div>
            <div class="chart-container">
              <h3 class="chart-title">Wait Time Analysis</h3>
              <canvas id="waitTimeAnalysisChart" width="400" height="200"></canvas>
            </div>
            <div class="chart-container">
              <h3 class="chart-title">Peak Hour Analysis</h3>
              <canvas id="peakHourAnalysisChart" width="400" height="200"></canvas>
            </div>
          </div>
        </div>
      </div>
    </section>
    <!-- Counters Section -->
    <section id="counters" class="section" style="display:none;">
      <div class="header">
        <h1 class="page-title">Counters</h1>
        <div class="header-actions">
          <button class="btn btn-primary" onclick="loadCounters()">üîÑ Refresh</button>
          <button class="btn btn-primary" onclick="openAddCounterModal()">‚ûï Add Counter</button>
        </div>
      </div>
      <div class="counter-grid" id="counters-list">Loading...</div>
    </section>
    <!-- Tickets Section -->
    <section id="tickets" class="section" style="display:none;">
      <div class="header">
        <h1 class="page-title">Tickets</h1>
        <button class="btn btn-primary" style="margin-bottom: 18px;" onclick="exportFullHistoryToExcel()">Export Full History</button>
      </div>
      <div class="table-container">
        <div id="fullHistorySection">
          <div style="margin-bottom: 20px; display: flex; gap: 10px; align-items: center;">
            <label for="historyDateFilter" style="font-weight: 600; color: #374151;">Filter by Date:</label>
            <input type="date" id="historyDateFilter" style="padding: 8px 12px; border: 1.5px solid #e5e7eb; border-radius: 6px; font-size: 0.9rem;">
            <button class="btn btn-primary" onclick="filterTicketsByDate()" style="padding: 8px 16px; font-size: 0.9rem;">Filter</button>
            <button class="btn btn-secondary" onclick="clearDateFilter()" style="padding: 8px 16px; font-size: 0.9rem;">Clear</button>
            <button class="btn btn-secondary" onclick="viewFullHistory()" style="padding: 8px 16px; font-size: 0.9rem;">View Full History</button>
            <button class="btn btn-primary" onclick="exportFilteredDataToExcel()" style="padding: 8px 16px; font-size: 0.9rem;">Export Filtered Data</button>
            <button class="btn btn-danger" onclick="deleteFilteredData()" style="padding: 8px 16px; font-size: 0.9rem;">Delete Filtered Data</button>
          </div>
          <h2 style="margin-bottom: 8px;">Ticket History</h2>
          <table>
            <thead>
              <tr>
                <th>Ticket #</th>
                <th>Service</th>
                <th>Status</th>
                <th>Wait Time</th>
                <th>Counter</th>
                <th>Created At</th>
                <th>Resolved At</th>
              </tr>
            </thead>
            <tbody id="tickets-history-list">
              <!-- Full history tickets will be loaded here -->
            </tbody>
          </table>
        </div>
      </div>
    </section>
    <!-- Settings Section -->
    <section id="settings" class="section" style="display:none;">
      <div class="header">
        <h1 class="page-title">User Settings</h1>
      </div>
      <div class="settings-container" style="max-width: 400px; margin: 0 auto; background: #fff; border-radius: 12px; box-shadow: 0 1px 3px rgba(0,0,0,0.08); padding: 32px 24px;">
        <form id="userSettingsForm" autocomplete="off">
          <div class="form-group" style="margin-bottom: 18px;">
            <label for="settingsUsername" style="display: block; margin-bottom: 6px; font-weight: 500; color: #374151;">Username</label>
            <input type="text" id="settingsUsername" name="settingsUsername" class="form-input" style="width: 100%; padding: 10px 14px; border: 1.5px solid #e5e7eb; border-radius: 8px; font-size: 1rem; background: #f9fafb;" required>
          </div>
          <div class="form-group" style="margin-bottom: 18px;">
            <label for="settingsNewPassword" style="display: block; margin-bottom: 6px; font-weight: 500; color: #374151;">New Password</label>
            <input type="password" id="settingsNewPassword" name="settingsNewPassword" class="form-input" style="width: 100%; padding: 10px 14px; border: 1.5px solid #e5e7eb; border-radius: 8px; font-size: 1rem; background: #f9fafb;">
          </div>
          <div class="form-group" style="margin-bottom: 18px;">
            <label for="settingsConfirmPassword" style="display: block; margin-bottom: 6px; font-weight: 500; color: #374151;">Confirm Password</label>
            <input type="password" id="settingsConfirmPassword" name="settingsConfirmPassword" class="form-input" style="width: 100%; padding: 10px 14px; border: 1.5px solid #e5e7eb; border-radius: 8px; font-size: 1rem; background: #f9fafb;">
          </div>
          <div style="margin-bottom: 18px; display: flex; align-items: center; gap: 10px;">
            <input type="checkbox" id="systemEnabledToggle" style="transform:scale(1.3);" />
            <label for="systemEnabledToggle" style="margin:0; font-weight:600; color:#374151;">System Enabled (Queue Open)</label>
            <span id="systemStatusLabel" style="margin-left:10px; font-weight:600;"></span>
          </div>
          <div style="display: flex; gap: 10px; margin-top: 10px;">
            <button type="submit" class="btn btn-primary" style="flex: 1;">Save</button>
            <button type="button" class="btn" id="settingsCancelBtn" style="flex: 1; background: #e5e7eb; color: #334155;">Discard</button>
          </div>
        </form>
        <button class="btn btn-danger" style="margin-top: 24px; width: 100%;" onclick="resetSystem()">Reset System & Clear All Tickets</button>
        <div id="settingsMessage" style="margin-top: 18px; display: none;"></div>
      </div>
    </section>
  </main>
  <!-- Counter Edit Modal -->
  <div id="counterModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.25); z-index:10000; align-items:center; justify-content:center;">
    <div class="modal-content" style="background:white; border-radius:12px; padding:32px 24px; min-width:320px; max-width:90vw; box-shadow:0 4px 24px rgba(0,0,0,0.18); position:relative;">
      <button onclick="closeCounterModal()" style="position:absolute; top:12px; right:16px; background:none; border:none; font-size:1.5rem; color:#64748b; cursor:pointer;">&times;</button>
      <h2 id="counterModalTitle" style="margin-bottom:18px;">Edit Counter</h2>
      <form id="counterEditForm" onsubmit="saveCounterEdit(event)">
        <div style="margin-bottom:14px;">
          <label>Counter Name</label>
          <input type="text" id="modalCounterName" name="modalCounterName" style="width:100%; padding:8px; border:1.5px solid #e5e7eb; border-radius:6px; margin-top:4px;" required />
        </div>
        <div style="margin-bottom:14px;">
          <label>Counter Number</label>
          <input type="number" id="modalCounterNumber" name="modalCounterNumber" min="1" max="99" style="width:100%; padding:8px; border:1.5px solid #e5e7eb; border-radius:6px; margin-top:4px;" required />
        </div>
        <div style="margin-bottom:14px;">
          <label>Counter Prefix</label>
          <input type="text" id="modalCounterPrefix" name="modalCounterPrefix" maxlength="4" style="width:100%; padding:8px; border:1.5px solid #e5e7eb; border-radius:6px; margin-top:4px; text-transform:uppercase;" required />
        </div>
        <div style="margin-bottom:14px;">
          <label>Counter Icon (emoji)</label>
          <input type="text" id="modalCounterIcon" name="modalCounterIcon" maxlength="2" style="width:100%; padding:8px; border:1.5px solid #e5e7eb; border-radius:6px; margin-top:4px; font-size:1.5rem; text-align:center;" placeholder="e.g. üè¢" />
        </div>
        <div style="margin-bottom:14px; display:flex; align-items:center; gap:10px;">
          <input type="checkbox" id="modalCounterEnabled" name="modalCounterEnabled" style="transform:scale(1.2);" />
          <label for="modalCounterEnabled" style="margin:0;">Enabled (show in kiosk & display)</label>
        </div>
        <div style="display:flex; gap:10px; margin-top:18px;">
          <button type="submit" class="btn btn-primary" style="flex:1;">Save</button>
          <button type="button" class="btn btn-danger" style="flex:1;" onclick="deleteCounter()">Delete</button>
        </div>
      </form>
    </div>
  </div>
  <script>
            const API = './index.php';

    // Authentication check
    function checkAuthentication() {
        const isAuthenticated = sessionStorage.getItem('adminAuthenticated');
        if (isAuthenticated !== 'true') {
            window.location.href = 'admin-login.html';
            return false;
        }
        return true;
    }
    // Logout function
    function logout() {
        sessionStorage.removeItem('adminAuthenticated');
        sessionStorage.removeItem('adminUsername');
        sessionStorage.removeItem('loginTime');
        window.location.href = 'admin-login.html';
    }
    // Check authentication on page load
    if (!checkAuthentication()) {
        // Page will redirect, so we don't need to continue
        throw new Error('Authentication required');
    }

    // Navigation
    let countersInterval = null;
    function showSection(section, event) {
      document.querySelectorAll('.section').forEach(e => e.style.display = 'none');
      document.getElementById(section).style.display = 'block';
      document.querySelectorAll('.nav-item').forEach(e => e.classList.remove('active'));
      if (event) event.target.classList.add('active');
      if (section === 'overview') loadOverview();
      if (section === 'counters') {
        loadCounters();
        // Start auto-refresh for counters
        if (countersInterval) clearInterval(countersInterval);
        countersInterval = setInterval(() => {
          // Only refresh if counters section is still visible
          if (document.getElementById('counters').style.display !== 'none') {
            loadCounters();
          } else {
            clearInterval(countersInterval);
          }
        }, 1000);
      } else {
        if (countersInterval) clearInterval(countersInterval);
      }
      if (section === 'tickets') loadTickets();
      if (section === 'settings') loadUserSettingsForm();
    }

    // Overview Data
    async function loadOverview() {
      const res = await fetch(`${API}?action=admin_analytics`);
      const data = await res.json();
      
      // Apply date filter to stats if set
      let totalTickets = data.analytics?.total_tickets || 0;
      let nowServing = data.analytics?.now_serving || 0;
      let waiting = data.analytics?.waiting || 0;
      
      if (overviewDateFilter) {
        const tickets = await fetchSharedTicketsData();
        const filteredTickets = tickets.filter(t => {
          if (!t.created_at) return false;
          let ticketDate = t.created_at.includes('T') ? t.created_at.split('T')[0] : t.created_at.split(' ')[0];
          return ticketDate === overviewDateFilter;
        });
        
        totalTickets = filteredTickets.length;
        nowServing = filteredTickets.filter(t => t.status === 'Now Serving').length;
        waiting = filteredTickets.filter(t => t.status === 'Waiting').length;
      }
      
      document.getElementById('stat-total').textContent = totalTickets;
      document.getElementById('stat-serving').textContent = nowServing;
      document.getElementById('stat-waiting').textContent = waiting;
      document.getElementById('stat-rate').textContent = (data.analytics?.service_rate || 0) + '%';
      // Use shared ticket data for overview charts
      fetchSharedTicketsData().then(tickets => {
        let filteredTickets = tickets;
        if (overviewDateFilter) {
          filteredTickets = tickets.filter(t => {
            if (!t.created_at) return false;
            let ticketDate = t.created_at.includes('T') ? t.created_at.split('T')[0] : t.created_at.split(' ')[0];
            return ticketDate === overviewDateFilter;
          });
        }
        
        renderOverviewCharts(
          data.analytics?.hourly_ticket_distribution || [],
          data.analytics?.service_performance_by_counter || [],
          filteredTickets
        );
      });
    }

    // Counters Data
    async function loadCounters() {
      const res = await fetch(`${API}?action=admin_counters`);
      const data = await res.json();
      let html = '';
      data.counters.forEach(c => {
        html += `
        <div class="counter-control">
          <div class="counter-header">
            <div class="counter-title">
              <span class="counter-prefix" style="font-size:1.5rem; margin-right:8px;">${c.icon || '‚ùì'}</span>
              <span style="font-size:0.95rem; color:#64748b; font-weight:600; margin-right:8px;">${c.prefix}</span>
              Counter ${c.counter_number} - ${c.name}
              ${c.enabled ? '' : '<span style=\'color:#dc2626;font-size:0.9em;margin-left:8px;\'>(Disabled)</span>'}
            </div>
            <span class="status-badge status-${(c.status || 'closed').toLowerCase()}">${(c.status || 'CLOSED').toUpperCase()}</span>
            <button class="counter-cog-btn" onclick="openCounterModal(${c.counter_number}, '${c.name.replace(/'/g, "'\\''")}', '${c.prefix}', event, '${c.icon || ''}', ${c.enabled})" style="background:none; border:none; cursor:pointer; font-size:1.3rem; margin-left:8px; color:#64748b; float:right;">
              ‚öôÔ∏è
            </button>
          </div>
          <div class="counter-info">
            <div class="info-row"><span class="info-label">Service:</span> <span class="info-value">${c.name}</span></div>
            <div class="info-row"><span class="info-label">Current Ticket:</span> <span class="info-value">${c.ticket_number || '-'}</span></div>
            <div class="info-row"><span class="info-label">Queue Length:</span> <span class="info-value">${c.queue_length}</span></div>
          </div>
          ${c.ticket_number ? `
          <div class="counter-actions">
            <button class="btn btn-primary btn-small" onclick="clearTicketResolved(${c.counter_number}, '${c.ticket_number}')">Resolve</button>
            <button class="btn btn-primary btn-small" onclick="markAsServing(${c.counter_number}, '${c.ticket_number}')">Mark as Serving</button>
          </div>
          ` : ''}
        </div>
        `;
      });
      document.getElementById('counters-list').innerHTML = html;
    }

    // Clear as Resolved: Mark ticket as Done
    async function clearTicketResolved(counterNumber, ticketNumber) {
      if (!confirm(`Mark ticket ${ticketNumber} as resolved?`)) return;
      
      try {
        const response = await fetch(`${API}?action=admin_clear&ticket_code=${encodeURIComponent(ticketNumber)}`, { 
          method: 'DELETE' 
        });
        
        const result = await response.json();
        
        if (result.success) {
          showNotification(`Ticket ${ticketNumber} resolved successfully`, 'success');
          // Add small delay to prevent rapid clicking issues
          await new Promise(resolve => setTimeout(resolve, 500));
          loadCounters();
          loadOverview();
          loadTickets();
        } else {
          showNotification(`Failed to resolve ticket: ${result.error || 'Unknown error'}`, 'error');
        }
      } catch (error) {
        console.error('Resolve ticket error:', error);
        showNotification('Failed to resolve ticket. Please try again.', 'error');
      }
    }

    // Add serveNext function
    async function serveNext(counterNumber) {
      // Find the next waiting ticket for this counter
      const res = await fetch(`${API}?action=admin_tickets`);
      const data = await res.json();
      const nextTicket = (data.tickets || []).find(t => t.counter == counterNumber && t.status === 'Waiting');
      if (!nextTicket) {
        alert('No waiting tickets for this counter.');
        return;
      }
      // Mark as Now Serving
      await fetch(`${API}?action=status_update&counter=${counterNumber}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ code: nextTicket.ticket_code, status: 'Now Serving' })
      });
      loadCounters();
      loadOverview();
      loadTickets();
    }

    // Mark ticket as Now Serving
    async function markAsServing(counterNumber, ticketNumber) {
      if (!confirm(`Mark ticket ${ticketNumber} as 'Now Serving'?`)) return;
      
      try {
        const response = await fetch(`${API}?action=status_update&counter=${counterNumber}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ code: ticketNumber, status: 'Now Serving' })
        });
        
        const result = await response.json();
        
        if (result.success) {
          showNotification(`Ticket ${ticketNumber} marked as 'Now Serving'`, 'success');
          // Add small delay to prevent rapid clicking issues
          await new Promise(resolve => setTimeout(resolve, 500));
          loadCounters();
          loadOverview();
          loadTickets();
        } else {
          showNotification(`Failed to mark ticket: ${result.error || 'Unknown error'}`, 'error');
        }
      } catch (error) {
        console.error('Mark as serving error:', error);
        showNotification('Failed to mark ticket as serving. Please try again.', 'error');
      }
    }

    // Tickets Data
    async function loadTickets() {
      // Load all tickets for the always-visible history section
      await loadAllTicketsForHistory();
    }

    // Analytics Data
    async function loadAnalytics() {
      // Always fetch the latest ticket data from the backend for real-time analytics
      const res = await fetch(`${API}?action=admin_tickets`);
      const data = await res.json();
      const tickets = (data.tickets || []).slice();

      // --- 1. Daily Ticket Trends (last 14 days) ---
      const days = 14;
      const today = new Date();
      const dateLabels = [];
      const dateCounts = [];
      for (let i = days - 1; i >= 0; i--) {
        const d = new Date(today);
        d.setDate(today.getDate() - i);
        const label = d.toISOString().slice(0, 10);
        dateLabels.push(label);
        dateCounts.push(0);
      }
      tickets.forEach(t => {
        if (!t.created_at) return;
        let ticketDate = t.created_at.includes('T') ? t.created_at.split('T')[0] : t.created_at.split(' ')[0];
        const idx = dateLabels.indexOf(ticketDate);
        if (idx !== -1) dateCounts[idx]++;
      });
      if (window.dailyTrendsChartInstance) window.dailyTrendsChartInstance.destroy();
      const dailyCtx = document.getElementById('dailyTrendsChart').getContext('2d');
      window.dailyTrendsChartInstance = new Chart(dailyCtx, {
        type: 'line',
        data: {
          labels: dateLabels,
          datasets: [{
            label: 'Tickets Created',
            data: dateCounts,
            borderColor: '#3b82f6',
            backgroundColor: 'rgba(59, 130, 246, 0.1)',
            tension: 0.4,
            pointBackgroundColor: '#3b82f6',
            pointBorderColor: '#3b82f6',
            pointRadius: 5,
            pointHoverRadius: 7,
            pointStyle: 'circle',
            fill: false
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { position: 'top' } },
          scales: {
            x: { title: { display: true, text: 'Date' }, ticks: { autoSkip: false } },
            y: { title: { display: true, text: 'Tickets Created' }, beginAtZero: true, precision: 0 }
          }
        }
      });

      // --- 2. Tickets Per Counter (all time, DONUT chart) ---
      const counterMap = {};
      tickets.forEach(t => {
        if (!t.counter) return;
        counterMap[t.counter] = (counterMap[t.counter] || 0) + 1;
      });
      const counterLabels = Object.keys(counterMap);
      const counterCounts = counterLabels.map(k => counterMap[k]);
      if (window.counterPerformanceChartInstance) window.counterPerformanceChartInstance.destroy();
      const counterPerfCtx = document.getElementById('counterPerformanceChart').getContext('2d');
      window.counterPerformanceChartInstance = new Chart(counterPerfCtx, {
        type: 'doughnut',
        data: {
          labels: counterLabels,
          datasets: [{
            label: 'Tickets',
            data: counterCounts,
            backgroundColor: [
              '#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#6366f1', '#f472b6', '#a3e635', '#f87171', '#fbbf24', '#34d399', '#818cf8', '#f9a8d4', '#fde68a', '#fca5a5', '#6ee7b7', '#a5b4fc', '#fbcfe8', '#fef08a', '#f87171', '#bbf7d0'
            ]
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { position: 'right' },
            tooltip: { enabled: true }
          }
        }
      });

      // --- 3. Status Distribution (pie) ---
      const statusMap = {};
      tickets.forEach(t => {
        statusMap[t.status] = (statusMap[t.status] || 0) + 1;
      });
      const statusLabels = Object.keys(statusMap);
      const statusCounts = statusLabels.map(k => statusMap[k]);
      if (window.serviceDistributionChartInstance) window.serviceDistributionChartInstance.destroy();
      const statusCtx = document.getElementById('serviceDistributionChart').getContext('2d');
      window.serviceDistributionChartInstance = new Chart(statusCtx, {
        type: 'pie',
        data: {
          labels: statusLabels,
          datasets: [{
            label: 'Tickets',
            data: statusCounts,
            backgroundColor: ['#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#6366f1', '#f472b6', '#a3e635']
          }]
        },
        options: { responsive: true, maintainAspectRatio: false }
      });

      // --- 4. Average Wait Time Per Counter ---
      const waitMap = {};
      const waitCount = {};
      tickets.forEach(t => {
        if (!t.counter) return;
        if (t.status !== 'Done' || !t.created_at || !t.updated_at) return;
        const created = new Date(t.created_at);
        const resolved = new Date(t.updated_at);
        const wait = (resolved - created) / 60000; // minutes
        if (!isNaN(wait) && wait >= 0) {
          waitMap[t.counter] = (waitMap[t.counter] || 0) + wait;
          waitCount[t.counter] = (waitCount[t.counter] || 0) + 1;
        }
      });
      const waitLabels = Object.keys(waitMap);
      const waitAverages = waitLabels.map(k => waitCount[k] ? (waitMap[k] / waitCount[k]).toFixed(1) : 0);
      if (window.waitTimeChartInstance) window.waitTimeChartInstance.destroy();
      const waitCtx = document.getElementById('waitTimeChart').getContext('2d');
      window.waitTimeChartInstance = new Chart(waitCtx, {
        type: 'bar',
        data: {
          labels: waitLabels,
          datasets: [{
            label: 'Avg Wait (min)',
            data: waitAverages,
            backgroundColor: '#6366f1'
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: { x: { title: { display: true, text: 'Counter' } } }
        }
      });

      // --- 5. Peak Hours (tickets per hour) ---
      const hourMap = Array(24).fill(0);
      tickets.forEach(t => {
        if (!t.created_at) return;
        const d = new Date(t.created_at);
        const hour = d.getHours();
        hourMap[hour]++;
      });
      const hourLabels = Array.from({length: 24}, (_, i) => (i === 0 ? '12AM' : i < 12 ? i + 'AM' : (i === 12 ? '12PM' : (i-12) + 'PM')));
      if (window.peakHoursChartInstance) window.peakHoursChartInstance.destroy();
      const peakCtx = document.getElementById('peakHoursChart').getContext('2d');
      window.peakHoursChartInstance = new Chart(peakCtx, {
        type: 'bar',
        data: {
          labels: hourLabels,
          datasets: [{
            label: 'Tickets',
            data: hourMap,
            backgroundColor: '#f59e0b'
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: { x: { title: { display: true, text: 'Hour' } } }
        }
      });

      // --- 6. System Efficiency (resolved/total ratio per day) ---
      const effMap = {};
      const effTotal = {};
      tickets.forEach(t => {
        if (!t.created_at) return;
        let ticketDate = t.created_at.includes('T') ? t.created_at.split('T')[0] : t.created_at.split(' ')[0];
        effTotal[ticketDate] = (effTotal[ticketDate] || 0) + 1;
        if (t.status === 'Done') effMap[ticketDate] = (effMap[ticketDate] || 0) + 1;
      });
      const effLabels = dateLabels;
      const effRatios = effLabels.map(d => effTotal[d] ? (100 * (effMap[d] || 0) / effTotal[d]).toFixed(1) : 0);
      if (window.efficiencyChartInstance) window.efficiencyChartInstance.destroy();
      const effCtx = document.getElementById('efficiencyChart').getContext('2d');
      window.efficiencyChartInstance = new Chart(effCtx, {
        type: 'line',
        data: {
          labels: effLabels,
          datasets: [{
            label: 'Efficiency (%)',
            data: effRatios,
            borderColor: '#16a34a',
            backgroundColor: 'rgba(22,163,74,0.1)',
            tension: 0.4,
            pointBackgroundColor: '#16a34a',
            pointBorderColor: '#16a34a',
            pointRadius: 5,
            pointHoverRadius: 7,
            pointStyle: 'circle',
            fill: false
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { position: 'top' } },
          scales: {
            x: { title: { display: true, text: 'Date' }, ticks: { autoSkip: false } },
            y: { title: { display: true, text: 'Efficiency (%)' }, beginAtZero: true, max: 100 }
          }
        }
      });
    }

    // User info (mock, you can adapt)
    function displayUserInfo() {
      const username = sessionStorage.getItem('adminUsername') || 'Admin';
      const loginTime = sessionStorage.getItem('loginTime');
      document.getElementById('currentUser').textContent = username;
      if (loginTime) {
        const loginDate = new Date(loginTime);
        const now = new Date();
        const diffInHours = Math.floor((now - loginDate) / (1000 * 60 * 60));
        if (diffInHours < 1) {
          document.getElementById('loginTime').textContent = 'Logged in recently';
        } else if (diffInHours === 1) {
          document.getElementById('loginTime').textContent = 'Logged in 1 hour ago';
        } else {
          document.getElementById('loginTime').textContent = `Logged in ${diffInHours} hours ago`;
        }
      } else {
        document.getElementById('loginTime').textContent = 'Logged in today';
      }
    }

    // Initial page load
    displayUserInfo();
    loadOverview();
    
    // Set up midnight refresh timer
    setupMidnightRefresh();

    // Add Chart.js for overview graphs
    let hourlyChartInstance = null;
    let performanceChartInstance = null;
    let dailyTrend7ChartInstance = null;
    let waitTimeAnalysisChartInstance = null;
    let peakHourAnalysisChartInstance = null;
    
    // Midnight refresh functionality
    function setupMidnightRefresh() {
      function checkMidnight() {
        const now = new Date();
        const currentHour = now.getHours();
        const currentMinute = now.getMinutes();
        
        // Check if it's midnight (00:00)
        if (currentHour === 0 && currentMinute === 0) {
          console.log('Midnight detected - refreshing data for new day');
          
          // Call backend to reset ticket counters
          fetch(`${API}?action=midnight_reset`, { method: 'POST' })
            .then(res => res.json())
            .then(data => {
              console.log('Midnight reset response:', data);
              if (data.success) {
                showNotification('Ticket counters reset for new day', 'success');
              }
            })
            .catch(err => {
              console.error('Midnight reset failed:', err);
              showNotification('Failed to reset ticket counters', 'error');
            });
          
          // Refresh dashboard data
          loadOverview();
          loadTickets();
          
          // Show notification to user
          if (document.getElementById('overview').style.display !== 'none') {
            showNotification('Data refreshed for new day', 'success');
          }
        }
      }
      
      // Check every minute for midnight
      setInterval(checkMidnight, 60000);
      
      // Also check immediately in case page was loaded at midnight
      checkMidnight();
    }
    
    // Notification function
    function showNotification(message, type = 'info') {
      // Create notification element
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 12px 20px;
        border-radius: 8px;
        color: white;
        font-weight: 600;
        z-index: 1000;
        background: ${type === 'success' ? '#10b981' : '#3b82f6'};
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        animation: slideIn 0.3s ease-out;
      `;
      notification.textContent = message;
      
      // Add animation styles
      const style = document.createElement('style');
      style.textContent = `
        @keyframes slideIn {
          from { transform: translateX(100%); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
        }
      `;
      document.head.appendChild(style);
      
      document.body.appendChild(notification);
      
      // Remove notification after 5 seconds
      setTimeout(() => {
        notification.style.animation = 'slideOut 0.3s ease-in';
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 300);
      }, 5000);
    }
    
    function renderOverviewCharts(hourlyData = [], servicePerformance = [], ticketsData = null) {
      // Destroy previous instances if they exist
      if (hourlyChartInstance) hourlyChartInstance.destroy();
      if (performanceChartInstance) performanceChartInstance.destroy();

      // Hourly Ticket Distribution (real data)
      const hourlyCtx = document.getElementById('hourlyChart').getContext('2d');
      const hourLabels = Array.from({length: 24}, (_, i) => (i === 0 ? '12AM' : i < 12 ? i + 'AM' : (i === 12 ? '12PM' : (i-12) + 'PM')));
      
      // Calculate hourly distribution from filtered tickets data
      let hourlyDistribution = Array(24).fill(0);
      if (ticketsData && ticketsData.length > 0) {
        ticketsData.forEach(t => {
          if (t.created_at) {
            const created = new Date(t.created_at);
            const hour = created.getHours();
            hourlyDistribution[hour]++;
          }
        });
      }
      
      // Prepare per-point styling: black if >0, transparent if 0
      const pointBgColors = hourlyDistribution.map(v => v > 0 ? '#000' : 'rgba(0,0,0,0)');
      const pointBorderColors = pointBgColors;
      const pointRadii = hourlyDistribution.map(v => v > 0 ? 4 : 0);
      const pointHoverRadii = hourlyDistribution.map(v => v > 0 ? 6 : 0);
      
      hourlyChartInstance = new Chart(hourlyCtx, {
        type: 'line',
        data: {
          labels: hourLabels,
          datasets: [{
            label: 'Tickets Created',
            data: hourlyDistribution,
            borderColor: '#3b82f6',
            backgroundColor: 'rgba(59, 130, 246, 0.1)',
            tension: 0.4,
            pointBackgroundColor: pointBgColors,
            pointBorderColor: pointBorderColors,
            pointRadius: pointRadii,
            pointHoverRadius: pointHoverRadii,
            pointStyle: 'circle'
          }]
        },
        options: { responsive: true, maintainAspectRatio: false }
      });

      // Service Performance by Counter (real data)
      const perfCtx = document.getElementById('performanceChart').getContext('2d');
      
      // Calculate service performance from filtered tickets data
      let counterPerformance = [];
      if (ticketsData && ticketsData.length > 0) {
        const counterMap = {};
        ticketsData.forEach(t => {
          if (t.counter) {
            counterMap[t.counter] = (counterMap[t.counter] || 0) + 1;
          }
        });
        
        // Convert to array format for chart
        counterPerformance = Object.entries(counterMap).map(([counter, count]) => ({
          counter_number: parseInt(counter),
          tickets_served: count
        })).sort((a, b) => a.counter_number - b.counter_number);
      }
      
      const counterLabels = counterPerformance.map(c => c.counter_number);
      const ticketsServed = counterPerformance.map(c => c.tickets_served);
      
      performanceChartInstance = new Chart(perfCtx, {
        type: 'bar',
        data: {
          labels: counterLabels,
          datasets: [{
            label: 'Tickets Served',
            data: ticketsServed,
            backgroundColor: '#10b981'
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              title: { display: true, text: 'Counter Number' }
            }
          }
        }
      });
    }

    // Analytics chart instances
    let dailyTrendsChartInstance = null;
    let serviceDistributionChartInstance = null;
    let waitTimeChartInstance = null;
    let counterPerformanceChartInstance = null;
    let peakHoursChartInstance = null;
    let efficiencyChartInstance = null;

    function renderAnalyticsCharts(analytics = {}) {
      if (window.dailyTrendsChartInstance) window.dailyTrendsChartInstance.destroy();
      const dailyCtx = document.getElementById('dailyTrendsChart').getContext('2d');
      window.dailyTrendsChartInstance = new Chart(dailyCtx, {
        type: 'line',
        data: {
          labels: analytics.daily_trends_labels || [],
          datasets: [
            {
              label: 'Tickets Created',
              data: analytics.daily_trends_created || [],
              borderColor: '#3b82f6',
              backgroundColor: 'rgba(59, 130, 246, 0.1)',
              tension: 0.4,
              pointBackgroundColor: '#3b82f6',
              pointBorderColor: '#3b82f6',
              pointRadius: 5,
              pointHoverRadius: 7,
              pointStyle: 'circle',
              fill: false
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { position: 'top' } },
          scales: {
            x: {
              title: { display: true, text: 'Date' },
              ticks: { autoSkip: false }
            },
            y: {
              title: { display: true, text: 'Tickets Created' },
              beginAtZero: true,
              precision: 0
            }
          }
        }
      });
    }

    // Render Daily Ticket Trend (Last 7 Days) in Analytics tab
    async function renderDailyTrend7Chart() {
      if (dailyTrend7ChartInstance) dailyTrend7ChartInstance.destroy();
      const tickets = await fetchSharedTicketsData();
      
      // Apply date filter if set
      let filteredTickets = tickets;
      if (analyticsDateFilter) {
        filteredTickets = tickets.filter(t => {
          if (!t.created_at) return false;
          let ticketDate = t.created_at.includes('T') ? t.created_at.split('T')[0] : t.created_at.split(' ')[0];
          return ticketDate === analyticsDateFilter;
        });
      }
      
      const days = 7;
      const today = new Date();
      const dateLabels = [];
      const dateCounts = [];
      for (let i = days - 1; i >= 0; i--) {
        const d = new Date(today);
        d.setDate(today.getDate() - i);
        const label = d.toISOString().slice(0, 10);
        dateLabels.push(label);
        dateCounts.push(0);
      }
      filteredTickets.forEach(t => {
        if (!t.created_at) return;
        let ticketDate = t.created_at.includes('T') ? t.created_at.split('T')[0] : t.created_at.split(' ')[0];
        const idx = dateLabels.indexOf(ticketDate);
        if (idx !== -1) dateCounts[idx]++;
      });
      const dailyTrend7Ctx = document.getElementById('dailyTrend7Chart').getContext('2d');
      dailyTrend7ChartInstance = new Chart(dailyTrend7Ctx, {
        type: 'line',
        data: {
          labels: dateLabels,
          datasets: [{
            label: 'Tickets Created',
            data: dateCounts,
            borderColor: '#6366f1',
            backgroundColor: 'rgba(99,102,241,0.1)',
            tension: 0.4,
            pointBackgroundColor: '#6366f1',
            pointBorderColor: '#6366f1',
            pointRadius: 5,
            pointHoverRadius: 7,
            pointStyle: 'circle',
            fill: false
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { position: 'top' } },
          scales: {
            x: { title: { display: true, text: 'Date' }, ticks: { autoSkip: false } },
            y: { title: { display: true, text: 'Tickets Created' }, beginAtZero: true, precision: 0 }
          }
        }
      });
      
      // Render Service Type Distribution Donut Chart
      renderServiceDistributionChart(filteredTickets);
      
      // Render Wait Time Analysis Chart
      renderWaitTimeAnalysisChart(filteredTickets);
      
      // Render Peak Hour Analysis Chart
      renderPeakHourAnalysisChart(filteredTickets);
    }

    // Render Service Type Distribution Donut Chart
    function renderServiceDistributionChart(tickets) {
      if (serviceDistributionChartInstance) serviceDistributionChartInstance.destroy();
      
      // Count tickets by service type (counter)
      const serviceCounts = {};
      tickets.forEach(t => {
        if (t.counter) {
          serviceCounts[t.counter] = (serviceCounts[t.counter] || 0) + 1;
        }
      });
      
      // Filter out services with 0 tickets
      const filteredServices = Object.entries(serviceCounts)
        .filter(([service, count]) => count > 0)
        .sort((a, b) => b[1] - a[1]); // Sort by count descending
      
      // Fetch counter information to get prefixes
      fetch(`${API}?action=admin_counters`).then(res => res.json()).then(data => {
        const counters = data.counters || [];
        const counterMap = {};
        counters.forEach(c => {
          counterMap[c.counter_number] = c.prefix;
        });
        
        const serviceLabels = filteredServices.map(([service]) => {
          const prefix = counterMap[service] || 'Unknown';
          return `${service} - ${prefix}`;
        });
        
        const serviceData = filteredServices.map(([, count]) => count);
        
        // Generate colors for each service
        const colors = ['#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#6366f1', '#f472b6', '#a3e635', '#f87171', '#fbbf24', '#34d399', '#818cf8', '#f9a8d4', '#fde68a', '#fca5a5', '#6ee7b7', '#a5b4fc', '#fbcfe8', '#fef08a', '#f87171', '#bbf7d0'];
        
        const serviceDistributionCtx = document.getElementById('serviceDistributionChart').getContext('2d');
        serviceDistributionChartInstance = new Chart(serviceDistributionCtx, {
          type: 'doughnut',
          data: {
            labels: serviceLabels,
            datasets: [{
              label: 'Tickets',
              data: serviceData,
              backgroundColor: serviceData.map((_, index) => colors[index % colors.length]),
              borderWidth: 2,
              borderColor: '#ffffff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { 
                position: 'right',
                labels: {
                  padding: 20,
                  usePointStyle: true
                }
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = ((context.parsed / total) * 100).toFixed(1) + '%';
                    return `${context.label}: ${context.parsed} tickets (${percentage})`;
                  }
                }
              }
            }
          }
        });
      });
    }

    // Render Wait Time Analysis Chart
    function renderWaitTimeAnalysisChart(tickets) {
      if (waitTimeAnalysisChartInstance) waitTimeAnalysisChartInstance.destroy();
      
      // Define wait time categories
      const categories = [
        { label: '0-5 mins', min: 0, max: 5 },
        { label: '5-10 mins', min: 5, max: 10 },
        { label: '11-15 mins', min: 11, max: 15 },
        { label: '16-20 mins', min: 16, max: 20 },
        { label: '21-30 mins', min: 21, max: 30 },
        { label: '30+ mins', min: 31, max: Infinity }
      ];
      
      // Count tickets in each category
      const categoryCounts = categories.map(() => 0);
      
      tickets.forEach(t => {
        if (t.status === 'Done' && t.created_at && t.updated_at) {
          const created = new Date(t.created_at);
          const resolved = new Date(t.updated_at);
          const waitTimeMinutes = Math.round((resolved - created) / 60000);
          if (waitTimeMinutes >= 0) {
            for (let i = 0; i < categories.length; i++) {
              const category = categories[i];
              if (waitTimeMinutes >= category.min && waitTimeMinutes <= category.max) {
                categoryCounts[i]++;
                break;
              }
            }
          }
        }
      });
      
      const labels = categories.map(c => c.label);
      
      const waitTimeCtx = document.getElementById('waitTimeAnalysisChart').getContext('2d');
      waitTimeAnalysisChartInstance = new Chart(waitTimeCtx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Number of Tickets',
            data: categoryCounts,
            backgroundColor: '#f59e0b',
            borderColor: '#d97706',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const total = context.dataset.data.reduce((a, b) => a + b, 0);
                  const percentage = total > 0 ? ((context.parsed / total) * 10).toFixed(1) : 0;
                  return `${context.parsed} tickets (${percentage}%)`;
                }
              }
            }
          },
          scales: {
            x: {
              title: {
                display: true,
                text: 'Wait Time Range'
              }
            },
            y: {
              title: {
                display: true,
                text: 'Number of Tickets'
              },
              beginAtZero: true,
              ticks: {
                precision: 0
              }
            }
          }
        }
      });
    }

    // Render Peak Hour Analysis Chart
    function renderPeakHourAnalysisChart(tickets) {
      if (peakHourAnalysisChartInstance) peakHourAnalysisChartInstance.destroy();
      
      // Initialize hour counts (0-23)
      const hourCounts = Array(24).fill(0);
      
      tickets.forEach(t => {
        if (t.created_at) {
          const created = new Date(t.created_at);
          const hour = created.getHours();
          hourCounts[hour]++;
        }
      });
      
      // Create hour labels (12AM,1, ...,11)
      const hourLabels = hourCounts.map((_, hour) => {
        if (hour === 0) return 12;
        if (hour < 12) return `${hour}AM`;
        if (hour === 12) return '12PM';
        return `${hour - 12}PM`;
      });
      
      const peakHourCtx = document.getElementById('peakHourAnalysisChart').getContext('2d');
      peakHourAnalysisChartInstance = new Chart(peakHourCtx, {
        type: 'bar',
        data: {
          labels: hourLabels,
          datasets: [{
            label: 'Tickets Created',
            data: hourCounts,
            backgroundColor: '#10b981',
            borderColor: '#059669',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return `${context.parsed} tickets created`;
                }
              }
            }
          },
          scales: {
            x: {
              title: {
                display: true,
                text: 'Hour of Day'
              }
            },
            y: {
              title: {
                display: true,
                text: 'Number of Tickets'
              },
              beginAtZero: true,
              ticks: {
                precision: 0
              }
            }
          }
        }
      });
    }

    // Render analytics charts when analytics tab is loaded
    function loadAnalytics() {
      renderAnalyticsCharts();
    }

    // Optional: Chart.js can be initialized here for <canvas> elements.
    // Example:
    // new Chart(document.getElementById('hourlyChart').getContext('2d'), {type:'bar',data:{},options:{}});

    // User Settings: Minimal Account Management
    function loadUserSettingsForm() {
      const username = sessionStorage.getItem('adminUsername') || 'admin';
      document.getElementById('settingsUsername').value = username;
      document.getElementById('settingsNewPassword').value = '';
      document.getElementById('settingsConfirmPassword').value = '';
      document.getElementById('settingsMessage').style.display = 'none';
    }
    // Load form values when settings tab is shown
    document.querySelector("button.nav-item#nav-settings").addEventListener('click', loadUserSettingsForm);
    // Cancel button resets form
    document.getElementById('settingsCancelBtn').addEventListener('click', function() {
      loadUserSettingsForm();
    });
    // Save (submit) handler
    document.getElementById('userSettingsForm').addEventListener('submit', function(e) {
      e.preventDefault();
      const newUsername = document.getElementById('settingsUsername').value.trim();
      const newPassword = document.getElementById('settingsNewPassword').value;
      const confirmPassword = document.getElementById('settingsConfirmPassword').value;
      const msgDiv = document.getElementById('settingsMessage');
      msgDiv.style.display = 'block';
      msgDiv.style.color = '#dc2626';
      // Validate username
      if (!newUsername) {
        msgDiv.textContent = 'Username cannot be empty.';
        return;
      }
      // Validate password match if password fields are filled
      if (newPassword || confirmPassword) {
        if (newPassword !== confirmPassword) {
          msgDiv.textContent = 'Passwords do not match.';
          return;
        }
        if (newPassword.length < 3) {
          msgDiv.textContent = 'Password must be at least 3 characters.';
          return;
        }
        sessionStorage.setItem('adminPassword', newPassword);
      }
      sessionStorage.setItem('adminUsername', newUsername);
      msgDiv.textContent = 'Profile updated successfully!';
      msgDiv.style.color = '#16a34a';
      // Update sidebar user info
      displayUserInfo();
      // Clear password fields
      document.getElementById('settingsNewPassword').value = '';
      document.getElementById('settingsConfirmPassword').value = '';
    });

    // Reset System: Clear all tickets
    async function resetSystem() {
      if (!confirm('Are you sure you want to reset the system and clear ALL tickets? This cannot be undone.')) return;
      const res = await fetch(`${API}?action=reset_system`, { method: 'POST' });
      if (res.ok) {
        alert('System reset: All tickets cleared.');
        loadOverview();
        loadCounters();
        loadTickets();
      } else {
        alert('Failed to reset system.');
      }
    }

    // Export full history to Excel using SheetJS
    async function exportFullHistoryToExcel() {
      const res = await fetch(`${API}?action=admin_tickets`);
      const data = await res.json();
      const tickets = (data.tickets || []);
      const wsData = [
        ['Ticket #', 'Service', 'Status', 'Wait Time (min)', 'Counter', 'Created At', 'Updated At']
      ];
      tickets.forEach(t => {
        wsData.push([
          t.ticket_code,
          t.service_name,
          t.status,
          t.wait_time_minutes,
          t.counter,
          t.created_at,
          t.updated_at
        ]);
      });
      const wb = XLSX.utils.book_new();
      const ws = XLSX.utils.aoa_to_sheet(wsData);
      XLSX.utils.book_append_sheet(wb, ws, 'Full History');
      XLSX.writeFile(wb, 'full_history_tickets.xlsx');
    }

    // Export filtered data to Excel
    function exportFilteredDataToExcel() {
      const selectedDate = document.getElementById('historyDateFilter').value;
      let ticketsToExport = [];
      
      if (selectedDate) {
        // Export filtered tickets for selected date
        ticketsToExport = allTicketsForHistory.filter(ticket => {
          if (!ticket.created_at) return false;
          
          let ticketDate;
          if (ticket.created_at.includes('T')) {
            ticketDate = ticket.created_at.split('T')[0];
          } else {
            ticketDate = ticket.created_at.split(' ')[0];
          }
          
          return ticketDate === selectedDate;
        });
      } else {
        // Export all tickets if no date is selected
        ticketsToExport = allTicketsForHistory;
      }
      
      const wsData = [
        ['Ticket #', 'Service', 'Status', 'Wait Time (min)', 'Counter', 'Created At', 'Updated At']
      ];
      
      ticketsToExport.forEach(t => {
        const created = t.created_at ? new Date(t.created_at) : null;
        const resolved = t.status === 'Done' && t.updated_at ? new Date(t.updated_at) : null;
        let waitTime = '-';
        if (created && resolved) {
          waitTime = Math.round((resolved - created) / 60000) + ' min';
        }
        
        wsData.push([
          t.ticket_code,
          t.service_name,
          t.status,
          waitTime,
          t.counter,
          t.created_at,
          t.updated_at
        ]);
      });
      
      const wb = XLSX.utils.book_new();
      const ws = XLSX.utils.aoa_to_sheet(wsData);
      const sheetName = selectedDate ? `Tickets_${selectedDate}` : 'All_Tickets';
      XLSX.utils.book_append_sheet(wb, ws, sheetName);
      
      const fileName = selectedDate ? `tickets_${selectedDate}.xlsx` : 'all_tickets.xlsx';
      XLSX.writeFile(wb, fileName);
    }

    // Delete filtered data
    async function deleteFilteredData() {
      const selectedDate = document.getElementById('historyDateFilter').value;
      let ticketsToDelete = [];
      
      if (selectedDate) {
        // Delete filtered tickets for selected date
        ticketsToDelete = allTicketsForHistory.filter(ticket => {
          if (!ticket.created_at) return false;
          
          let ticketDate;
          if (ticket.created_at.includes('T')) {
            ticketDate = ticket.created_at.split('T')[0];
          } else {
            ticketDate = ticket.created_at.split(' ')[0];
          }
          
          return ticketDate === selectedDate;
        });
      } else {
        // Delete all tickets if no date is selected
        ticketsToDelete = allTicketsForHistory;
      }
      
      if (ticketsToDelete.length === 0) {
        alert('No tickets found to delete for the selected criteria.');
        return;
      }
      
      const confirmMessage = selectedDate 
        ? `Are you sure you want to delete ${ticketsToDelete.length} tickets from ${selectedDate}? This action cannot be undone.`
        : `Are you sure you want to delete ALL ${ticketsToDelete.length} tickets? This action cannot be undone.`;
      
      if (!confirm(confirmMessage)) {
        return;
      }
      
      try {
        const ticketCodes = ticketsToDelete.map(t => t.ticket_code);
        const response = await fetch(`${API}?action=delete_tickets`, {
          method: 'DELETE',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            ticket_codes: ticketCodes,
            date: selectedDate || 'all'
          })
        });
        
        const result = await response.json();
        
        if (result.success) {
          showNotification(`Successfully deleted ${ticketsToDelete.length} tickets`, 'success');
          // Reload tickets data
          await loadTickets();
        } else {
          showNotification(`Failed to delete tickets: ${result.error}`, 'error');
        }
      } catch (error) {
        console.error('Delete error:', error);
        showNotification('Failed to delete tickets. Please try again.', 'error');
      }
    }

    // Store all tickets for filtering
    let allTicketsForHistory = [];

    // Load all tickets for history filtering
    async function loadAllTicketsForHistory() {
      const res = await fetch(`${API}?action=admin_tickets`);
      const data = await res.json();
      allTicketsForHistory = (data.tickets || []).slice().sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
      
      // Set current real-time date as default in the date picker
      const currentDate = new Date().toISOString().slice(0, 10);
      document.getElementById('historyDateFilter').value = currentDate;
      
      // Add event listener for automatic filtering
      document.getElementById('historyDateFilter').addEventListener('change', function() {
        if (this.value) {
          filterTicketsByDate();
        }
      });
      
      // Automatically filter by current date on load
      filterTicketsByDate();
    }

    // Filter tickets by selected date
    function filterTicketsByDate() {
      const selectedDate = document.getElementById('historyDateFilter').value;
      if (!selectedDate) {
        alert('Please select a date to filter by.');
        return;
      }
      
      console.log('Filtering by date:', selectedDate);
      console.log('All tickets for history:', allTicketsForHistory);
      
      const filteredTickets = allTicketsForHistory.filter(ticket => {
        if (!ticket.created_at) return false;
        
        // Extract date part from created_at (handle different formats)
        let ticketDate;
        if (ticket.created_at.includes('T')) {
          // Format: "2025-07-15T09:15:30+08:00"
          ticketDate = ticket.created_at.split('T')[0];
        } else {
          // Format: "2025-07-15 09:15:30"
          ticketDate = ticket.created_at.split(' ')[0];
        }
        
        console.log(`Ticket ${ticket.ticket_code}: created_at = ${ticket.created_at}, extracted date = ${ticketDate}, matches selected? ${ticketDate === selectedDate}`);
        
        return ticketDate === selectedDate;
      });
      
      console.log('Filtered tickets:', filteredTickets);
      renderHistoryTickets(filteredTickets, selectedDate);
    }

    // Clear date filter and show all history tickets
    function clearDateFilter() {
      document.getElementById('historyDateFilter').value = '';
      renderHistoryTickets(allTicketsForHistory, 'All Dates');
    }

    // View full history function
    function viewFullHistory() {
      document.getElementById('historyDateFilter').value = '';
      renderHistoryTickets(allTicketsForHistory, 'All Dates');
    }

    // Render history tickets with proper formatting
    function renderHistoryTickets(tickets, filterDate = 'All Dates') {
      let html = '';
      tickets.forEach(t => {
        const created = t.created_at ? new Date(t.created_at) : null;
        const resolved = t.status === 'Done' && t.updated_at ? new Date(t.updated_at) : null;
        let waitTime = '-';
        if (created && resolved) {
          waitTime = Math.round((resolved - created) / 60000) + ' min';
        }
        html += `
          <tr>
            <td>${t.ticket_code}</td>
            <td>${t.service_name}</td>
            <td>${t.status}</td>
            <td>${waitTime}</td>
            <td>${t.counter}</td>
            <td>${created ? created.toLocaleString() : '-'}</td>
            <td>${resolved ? resolved.toLocaleString() : '-'}</td>
          </tr>`;
      });
      
      const resultMessage = filterDate === 'All Dates' 
        ? `Showing all ${tickets.length} tickets from history`
        : `Showing ${tickets.length} tickets for ${filterDate}`;
        
      document.getElementById('tickets-history-list').innerHTML = html || '<tr><td colspan="7">No tickets found for selected criteria.</td></tr>';
      
      // Add result count message
      const existingMessage = document.querySelector('.history-result-message');
      if (existingMessage) existingMessage.remove();
      
      const messageDiv = document.createElement('div');
      messageDiv.className = 'history-result-message';
      messageDiv.style.cssText = 'margin-bottom: 10px; font-weight: 600; color: #374151;';
      messageDiv.textContent = resultMessage;
      
      const historyTable = document.querySelector('#fullHistorySection table');
      historyTable.parentNode.insertBefore(messageDiv, historyTable);
    }

    // Modal logic
    let currentCounterEdit = null;
    let isAddMode = false;
    function openAddCounterModal() {
      isAddMode = true;
      currentCounterEdit = null;
      document.getElementById('modalCounterNumber').value = '';
      document.getElementById('modalCounterName').value = '';
      document.getElementById('modalCounterPrefix').value = '';
      document.getElementById('modalCounterEnabled').checked = true;
      document.getElementById('modalCounterIcon').value = '';
      document.getElementById('counterModalTitle').textContent = 'Add Counter';
      document.getElementById('counterModal').style.display = 'block';
    }
    function openCounterModal(counterNumber, counterName, counterPrefix, event, icon, enabled) {
      event.stopPropagation();
      isAddMode = false;
      currentCounterEdit = { counterNumber, counterName, counterPrefix };
      document.getElementById('modalCounterNumber').value = counterNumber;
      document.getElementById('modalCounterName').value = counterName;
      document.getElementById('modalCounterPrefix').value = counterPrefix;
      document.getElementById('modalCounterEnabled').checked = !!enabled;
      document.getElementById('modalCounterIcon').value = icon || '';
      document.getElementById('counterModalTitle').textContent = 'Edit Counter';
      document.getElementById('counterModal').style.display = 'block';
    }
    function closeCounterModal() {
      document.getElementById('counterModal').style.display = 'none';
      currentCounterEdit = null;
    }
    function saveCounterEdit(e) {
      e.preventDefault();
      const num = parseInt(document.getElementById('modalCounterNumber').value, 10);
      const name = document.getElementById('modalCounterName').value.trim();
      const prefix = document.getElementById('modalCounterPrefix').value.trim().toUpperCase();
      const enabled = document.getElementById('modalCounterEnabled').checked;
      const icon = document.getElementById('modalCounterIcon').value.trim() || '‚ùì';
      if (isAddMode) {
        fetch(`${API}?action=add_counter`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ counter_number: num, name, prefix, enabled, icon })
        })
          .then(res => res.json())
          .then(data => {
            if (data.success) {
              showNotification('Counter added successfully', 'success');
              closeCounterModal();
              loadCounters();
            } else {
              showNotification(data.error || 'Failed to add counter', 'error');
            }
          })
          .catch(() => showNotification('Failed to add counter', 'error'));
      } else {
        fetch(`${API}?action=edit_counter`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ counter_number: num, name, prefix, enabled, icon })
        })
          .then(res => res.json())
          .then(data => {
            if (data.success) {
              showNotification('Counter updated successfully', 'success');
              closeCounterModal();
              loadCounters();
            } else {
              showNotification(data.error || 'Failed to update counter', 'error');
            }
          })
          .catch(() => showNotification('Failed to update counter', 'error'));
      }
    }
    function deleteCounter() {
      const num = parseInt(document.getElementById('modalCounterNumber').value, 10);
      if (!confirm('Are you sure you want to delete this counter? This cannot be undone.')) return;
      fetch(`${API}?action=delete_counter&counter_number=${num}`, {
        method: 'DELETE'
      })
        .then(res => res.json())
        .then(data => {
          if (data.success) {
            closeCounterModal();
            showNotification('Counter deleted successfully', 'success');
            loadCounters();
          } else {
            showNotification('Failed to delete counter: ' + (data.error || 'Unknown error'), 'error');
          }
        })
        .catch(() => {
          showNotification('Failed to delete counter. Please try again.', 'error');
        });
    }

    let systemEnabled = true;
    async function fetchSystemStatus() {
      try {
        const res = await fetch(`${API}?action=system_status`);
        const data = await res.json();
        systemEnabled = data.system_enabled !== false;
        document.getElementById('systemEnabledToggle').checked = systemEnabled;
        document.getElementById('systemStatusLabel').textContent = systemEnabled ? 'ENABLED' : 'DISABLED';
        document.getElementById('systemStatusLabel').style.color = systemEnabled ? '#16a34a' : '#dc2626';
        updateSystemBanner();
      } catch (e) {
        systemEnabled = true;
        document.getElementById('systemEnabledToggle').checked = true;
        document.getElementById('systemStatusLabel').textContent = 'ENABLED';
        document.getElementById('systemStatusLabel').style.color = '#16a34a';
        updateSystemBanner();
      }
    }
    document.getElementById('systemEnabledToggle').addEventListener('change', async function() {
      const enabled = this.checked;
      try {
        const res = await fetch(`${API}?action=set_system_status`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ enabled })
        });
        const data = await res.json();
        systemEnabled = data.system_enabled !== false;
        document.getElementById('systemStatusLabel').textContent = systemEnabled ? 'ENABLED' : 'DISABLED';
        document.getElementById('systemStatusLabel').style.color = systemEnabled ? '#16a34a' : '#dc2626';
        showNotification('System ' + (systemEnabled ? 'enabled' : 'disabled'), systemEnabled ? 'success' : 'error');
        updateSystemBanner();
      } catch (e) {
        showNotification('Failed to update system status', 'error');
        this.checked = !enabled;
      }
    });
    function updateSystemBanner() {
      let banner = document.getElementById('systemDisabledBanner');
      if (!systemEnabled) {
        if (!banner) {
          banner = document.createElement('div');
          banner.id = 'systemDisabledBanner';
          banner.style.cssText = 'position:fixed;top:0;left:0;width:100vw;padding:16px 0;background:#dc2626;color:white;font-weight:700;text-align:center;z-index:9999;font-size:1.2rem;';
          banner.textContent = 'The queue system is currently DISABLED by the administrator. All queue actions are blocked.';
          document.body.appendChild(banner);
        }
      } else {
        if (banner) banner.remove();
      }
      // Disable/enable queue actions
      const disableAll = !systemEnabled;
      // Example: disable ticket/counter actions
      // (You may want to add more selectors as needed)
      document.querySelectorAll('.btn-primary, .btn-danger, .btn-secondary').forEach(btn => {
        if (btn.id === 'systemEnabledToggle' || btn.closest('#settings')) return;
        btn.disabled = disableAll;
      });
    }
    // On page load, fetch system status
    fetchSystemStatus();
    // Also check system status before any queue/ticket action
    async function ensureSystemEnabled() {
      if (!systemEnabled) {
        showNotification('The queue system is currently DISABLED by the administrator.', 'error');
        throw new Error('System disabled');
      }
    }
    // Wrap queue/ticket actions to enforce system status
    const origClearTicketResolved = clearTicketResolved;
    clearTicketResolved = async function(...args) {
      await ensureSystemEnabled();
      return origClearTicketResolved.apply(this, args);
    };
    const origMarkAsServing = markAsServing;
    markAsServing = async function(...args) {
      await ensureSystemEnabled();
      return origMarkAsServing.apply(this, args);
    };
    const origServeNext = serveNext;
    serveNext = async function(...args) {
      await ensureSystemEnabled();
      return origServeNext.apply(this, args);
    };
    const origDeleteFilteredData = deleteFilteredData;
    deleteFilteredData = async function(...args) {
      await ensureSystemEnabled();
      return origDeleteFilteredData.apply(this, args);
    };
    const origResetSystem = resetSystem;
    resetSystem = async function(...args) {
      await ensureSystemEnabled();
      return origResetSystem.apply(this, args);
    };

    // Shared ticket data for overview and analytics
    let sharedTicketsData = null;
    let sharedTicketsDataTimestamp = 0;
    const SHARED_DATA_TTL = 10000; // 10 seconds cache

    async function fetchSharedTicketsData(force = false) {
      const now = Date.now();
      if (!force && sharedTicketsData && (now - sharedTicketsDataTimestamp < SHARED_DATA_TTL)) {
        return sharedTicketsData;
      }
      const res = await fetch(`${API}?action=admin_tickets`);
      const data = await res.json();
      sharedTicketsData = (data.tickets || []);
      sharedTicketsDataTimestamp = now;
      return sharedTicketsData;
    }

    // Toggle In Depth Analytics
    function toggleInDepthAnalytics() {
      const content = document.getElementById('inDepthAnalyticsContent');
      const toggleBtn = document.getElementById('toggleAnalyticsBtn');
      const toggleIcon = document.getElementById('toggleIcon');
      const toggleText = document.getElementById('toggleText');
      const dateFilter = document.getElementById('analyticsDateFilter');
      
      if (content.style.display === 'none') {
        content.style.display = 'block';
        dateFilter.style.display = 'block';
        toggleIcon.textContent = 'üìà';
        toggleText.textContent = 'Hide In Depth Analytics';
        // Render the chart when showing
        renderDailyTrend7Chart();
      } else {
        content.style.display = 'none';
        dateFilter.style.display = 'none';
        toggleIcon.textContent = 'üìä';
        toggleText.textContent = 'Show In Depth Analytics';
      }
    }

    // Date filter variables
    let overviewDateFilter = null;
    let analyticsDateFilter = null;
    
    // Apply Overview Date Filter
    function applyOverviewDateFilter() {
      overviewDateFilter = document.getElementById('overviewDateFilter').value;
      if (overviewDateFilter) {
        loadOverview();
        showNotification(`Overview filtered for ${overviewDateFilter}`, 'success');
      } else {
        showNotification('Please select a date to filter by.', 'error');
      }
    }
    
    // Clear Overview Date Filter
    function clearOverviewDateFilter() {
      overviewDateFilter = null;
      document.getElementById('overviewDateFilter').value = '';
      loadOverview();
      showNotification('Overview date filter cleared', 'success');
    }
    
    // Apply Analytics Date Filter
    function applyAnalyticsDateFilter() {
      analyticsDateFilter = document.getElementById('analyticsDateFilterInput').value;
      if (analyticsDateFilter) {
        renderDailyTrend7Chart();
        showNotification(`Analytics filtered for ${analyticsDateFilter}`, 'success');
      } else {
        showNotification('Please select a date to filter by.', 'error');
      }
    }
    
    // Clear Analytics Date Filter
    function clearAnalyticsDateFilter() {
      analyticsDateFilter = null;
      document.getElementById('analyticsDateFilterInput').value = '';
      renderDailyTrend7Chart();
      showNotification('Analytics date filter cleared', 'success');
    }

  </script>
  <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
</body>
</html>